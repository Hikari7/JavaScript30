<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JS Reference VS Copy</title>
  </head>
  <body>
    <p>See your console.logğŸ’–!</p>

    <script>
      //ğŸ’¡booleanå‹ã¨ã¯ã€å¤‰æ•°ã«æ ¼ç´ã™ã‚‹ã“ã¨ãŒã§ãã‚‹å€¤ã®ç¨®é¡ã®ã²ã¨ã¤ã§ã€trueãƒ»falseã¨ã„ã£ãŸçœŸå½å€¤ã‚’æ ¼ç´ã™ã‚‹ã“ã¨ãŒã§ãã‚‹

      // ğŸŒ¸start with strings, numbers and booleans
      // let age = 100;
      // let age2 = age;
      // console.log(age, age2);

      // let name = "Wes";
      // let name2 = name;
      // console.log(name, name2);
      // name = "Hikari";
      // console.log(name, name2);

      // ğŸŒ¸Let's say we have an array
      const players = ["Wes", "Sarah", "Ryan", "Poppy"];

      // ğŸŒ¸and we want to make a copy of it.
      const team = players;

      console.log(players, team);

      // You might think we can just do something like this:

      // team[3] = 'Lux';

      //  ğŸ’¡When you edit that original array or when you update any of the arrays, it's always going to go back to the reference where it was which it  not the same as what we did here with numbers, array.ã€€é…åˆ—å¤‰ãˆã‚‹ã¨ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚‚å¤‰ã‚ã£ã¡ã‚ƒã†ï¼Ÿâ†’é…åˆ—ã®ã‚³ãƒ”ãƒ¼ã‚’ä½œã‚‹ğŸ‘‡

      // however what happens when we update that array?

      // now here is the problem!

      // oh no - we have edited the original array too!

      // Why? It's because that is an array reference, not an array copy. They both point to the same array!

      // ğŸŒ¸So, how do we fix this? We take a copy instead!
      const team2 = players.slice();
      //æ–¹æ³•1: sliceã«ä½•ã‚‚æ¸¡ã•ãªã„ã¨å…¨éƒ¨ã®é…åˆ—ãŒãã®ã¾ã¾è¡¨ç¤ºã•ã‚Œã‚‹ã ã‘
      //â†’å®Ÿéš›ã®é…åˆ—ã®ã‚³ãƒ”ãƒ¼ãŒãã®ã¾ã¾æ¸¡ã•ã‚Œã‚‹ï¼

      // one way

      // ğŸŒ¸or create a new array and concat the old one in
      const team3 = [].concat(players);
      //æ–¹æ³•2: concat() ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€2ã¤ä»¥ä¸Šã®é…åˆ—ã‚’çµåˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹

      // or use the new ES6 Spread
      const team4 = [...players];
      team4[3] = "heeeee hawww";
      console.log(team4);

      //æ–¹æ³•3: ğŸ’¡ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ§‹æ–‡
      //é…åˆ—å¼ã‚„æ–‡å­—åˆ—ãªã©ã®åå¾©å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€0 å€‹ä»¥ä¸Šã®å¼•æ•° (é–¢æ•°å‘¼ã³å‡ºã—ã®å ´åˆ) ã‚„è¦ç´  (é…åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®å ´åˆ) ã‚’æœŸå¾…ã•ã‚ŒãŸå ´æ‰€ã§å±•é–‹ã—ãŸã‚Šã§ãã‚‹ã‚ˆ

      const team5 = Array.from(players);
      //æ–¹æ³•4: ğŸ’¡Array.from() ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é…åˆ—ã®ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„åå¾©å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã€æµ…ãã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸæ–°ã—ã„ Array ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹

      // now when we update it, the original one isn't changed

      //â­------------------------------------------â­//

      // The same thing goes for objects, let's say we have a person object

      // with Objects
      const person = {
        name: "Wes Bos",
        age: 80,
      };

      // and think we make a copy:
      // const captain = person;
      // captain.number = 99;

      // ğŸŒ¸how do we take a copy instead?
      const cap2 = Object.assign({}, person, { number: 99, age: 12 });
      console.log(cap2);

      //ğŸ’¡Object.assign() ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã™ã¹ã¦ã®åˆ—æŒ™å¯èƒ½ãªè‡ªèº«ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å€¤ã‚’ã€ 1 ã¤ä»¥ä¸Šã®ã‚³ãƒ”ãƒ¼å…ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã‚³ãƒ”ãƒ¼å…ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚we'd take a blank object, we overwrite or we sort of fold in all of the properties and values from our object, and then we use the third argument to fold in our own ones.

      // ğŸŒ¸We will hopefully soon see the object ...spread

      // const cap3 = {...person};

      //ğŸ’¡Reactã§ã™ã‚‹æ„Ÿã˜ï¼Ÿã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ§‹æ–‡ã¿ãŸã„ãªæ„Ÿã˜ï¼Ÿ

      // ğŸŒ¸Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.

      const wes = {
        name: "Wes",
        age: 100,
        social: {
          twitter: "@wesbos",
          facebook: "wesbos.developer",
        },
      };

      console.clear();
      console.log(wes);

      const dev = Object.assign({}, wes);

      //â†“ã‚¯ãƒ­ãƒ¼ãƒ³
      const dev2 = JSON.parse(JSON.stringify(wes));
    </script>
  </body>
</html>
