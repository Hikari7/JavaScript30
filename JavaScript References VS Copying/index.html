<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JS Reference VS Copy</title>
  </head>
  <body>
    <p>See your console.log💖!</p>

    <script>
      //💡boolean型とは、変数に格納することができる値の種類のひとつで、true・falseといった真偽値を格納することができる

      // 🌸start with strings, numbers and booleans
      // let age = 100;
      // let age2 = age;
      // console.log(age, age2);

      // let name = "Wes";
      // let name2 = name;
      // console.log(name, name2);
      // name = "Hikari";
      // console.log(name, name2);

      // 🌸Let's say we have an array
      const players = ["Wes", "Sarah", "Ryan", "Poppy"];

      // 🌸and we want to make a copy of it.
      const team = players;

      console.log(players, team);

      // You might think we can just do something like this:

      // team[3] = 'Lux';

      //  💡When you edit that original array or when you update any of the arrays, it's always going to go back to the reference where it was which it  not the same as what we did here with numbers, array.　配列変えるとオリジナルも変わっちゃう？→配列のコピーを作る👇

      // however what happens when we update that array?

      // now here is the problem!

      // oh no - we have edited the original array too!

      // Why? It's because that is an array reference, not an array copy. They both point to the same array!

      // 🌸So, how do we fix this? We take a copy instead!
      const team2 = players.slice();
      //方法1: sliceに何も渡さないと全部の配列がそのまま表示されるだけ
      //→実際の配列のコピーがそのまま渡される！

      // one way

      // 🌸or create a new array and concat the old one in
      const team3 = [].concat(players);
      //方法2: concat() メソッドは、2つ以上の配列を結合するために使用する

      // or use the new ES6 Spread
      const team4 = [...players];
      team4[3] = "heeeee hawww";
      console.log(team4);

      //方法3: 💡スプレッド構文
      //配列式や文字列などの反復可能オブジェクトを、0 個以上の引数 (関数呼び出しの場合) や要素 (配列リテラルの場合) を期待された場所で展開したりできるよ

      const team5 = Array.from(players);
      //方法4: 💡Array.from() メソッドは、配列のようなオブジェクトや反復可能オブジェクトから、浅くコピーされた新しい Array インスタンスを生成する

      // now when we update it, the original one isn't changed

      //⭐------------------------------------------⭐//

      // The same thing goes for objects, let's say we have a person object

      // with Objects
      const person = {
        name: "Wes Bos",
        age: 80,
      };

      // and think we make a copy:
      // const captain = person;
      // captain.number = 99;

      // 🌸how do we take a copy instead?
      const cap2 = Object.assign({}, person, { number: 99, age: 12 });
      console.log(cap2);

      //💡Object.assign() メソッドは、すべての列挙可能な自身のプロパティの値を、 1 つ以上のコピー元オブジェクトからコピー先オブジェクトにコピーするために使用されます。we'd take a blank object, we overwrite or we sort of fold in all of the properties and values from our object, and then we use the third argument to fold in our own ones.

      // 🌸We will hopefully soon see the object ...spread

      // const cap3 = {...person};

      //💡Reactでする感じ？スプレッド構文みたいな感じ？

      // 🌸Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.

      const wes = {
        name: "Wes",
        age: 100,
        social: {
          twitter: "@wesbos",
          facebook: "wesbos.developer",
        },
      };

      console.clear();
      console.log(wes);

      const dev = Object.assign({}, wes);

      //↓クローン
      const dev2 = JSON.parse(JSON.stringify(wes));
    </script>
  </body>
</html>
